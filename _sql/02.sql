-- ===================================================================
-- ШАГ 1: СОЗДАНИЕ НОВОЙ ТАБЛИЦЫ ДЛЯ УЧЕТА КАЖДОГО ДОБАВЛЕНИЯ
-- Эта таблица будет хранить записи вида "+50 шт.", "+120 шт."
-- ===================================================================
CREATE TABLE IF NOT EXISTS public.manufactured_log_entries (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    chat_id BIGINT NOT NULL,
    log_date DATE NOT NULL DEFAULT CURRENT_DATE,
    pie_type TEXT NOT NULL,
    quantity INT NOT NULL CHECK (quantity > 0),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    -- Связь с основной таблицей логов
    CONSTRAINT fk_daily_log
        FOREIGN KEY(chat_id, log_date, pie_type) 
        REFERENCES daily_log(chat_id, log_date, pie_type)
        ON DELETE CASCADE
);
ALTER TABLE public.manufactured_log_entries ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow anon full access to manufactured_log_entries" ON public.manufactured_log_entries FOR ALL TO anon USING (true) WITH CHECK (true);


-- ===================================================================
-- ШАГ 2: СОЗДАНИЕ НОВЫХ ФУНКЦИЙ ДЛЯ РАБОТЫ С ЗАПИСЯМИ
-- ===================================================================

-- ФУНКЦИЯ №1: Добавление новой записи о произведенной продукции.
-- Она заменит старую 'upsert_daily_manufactured'.
CREATE OR REPLACE FUNCTION public.add_manufactured_entry(p_chat_id BIGINT, p_pie_type TEXT, p_quantity INT)
RETURNS TABLE(new_total INT, remaining_reset BOOLEAN)
LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE
    v_remaining_was_not_null BOOLEAN;
BEGIN
    -- Сначала, как и раньше, создаем или находим запись в daily_log
    INSERT INTO public.daily_log (chat_id, log_date, pie_type, manufactured)
    VALUES (p_chat_id, CURRENT_DATE, p_pie_type, 0)
    ON CONFLICT (chat_id, log_date, pie_type) DO NOTHING;

    -- Проверяем, были ли уже введены остатки, чтобы сбросить их
    SELECT remaining IS NOT NULL INTO v_remaining_was_not_null
    FROM public.daily_log
    WHERE chat_id = p_chat_id AND log_date = CURRENT_DATE AND pie_type = p_pie_type;

    -- Обновляем общее количество и сбрасываем остаток
    UPDATE public.daily_log
    SET 
        manufactured = manufactured + p_quantity,
        remaining = CASE WHEN v_remaining_was_not_null THEN NULL ELSE remaining END,
        updated_at = NOW()
    WHERE chat_id = p_chat_id AND log_date = CURRENT_DATE AND pie_type = p_pie_type;

    -- А теперь добавляем запись в нашу новую "кассовую ленту"
    INSERT INTO public.manufactured_log_entries (chat_id, log_date, pie_type, quantity)
    VALUES (p_chat_id, CURRENT_DATE, p_pie_type, p_quantity);

    -- Возвращаем результат
    RETURN QUERY
    SELECT dl.manufactured, v_remaining_was_not_null AS remaining_reset
    FROM public.daily_log dl
    WHERE dl.chat_id = p_chat_id AND dl.log_date = CURRENT_DATE AND dl.pie_type = p_pie_type;
END;
$$;


-- ФУНКЦИЯ №2: Удаление конкретной записи по её ID.
CREATE OR REPLACE FUNCTION public.delete_manufactured_entry(p_entry_id BIGINT, p_chat_id BIGINT)
RETURNS TABLE(new_total INT, remaining_reset BOOLEAN)
LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE
    v_deleted_quantity INT;
    v_pie_type TEXT;
    v_log_date DATE;
    v_remaining_was_not_null BOOLEAN;
BEGIN
    -- Находим и удаляем запись, получая её данные
    DELETE FROM public.manufactured_log_entries
    WHERE id = p_entry_id AND chat_id = p_chat_id
    RETURNING quantity, pie_type, log_date INTO v_deleted_quantity, v_pie_type, v_log_date;

    -- Если ничего не удалено (например, неверный ID), выходим
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Запись с ID % не найдена для этого пользователя.', p_entry_id;
    END IF;

    -- Проверяем, были ли остатки, чтобы предупредить о сбросе
    SELECT remaining IS NOT NULL INTO v_remaining_was_not_null
    FROM public.daily_log
    WHERE chat_id = p_chat_id AND log_date = v_log_date AND pie_type = v_pie_type;

    -- Обновляем основную таблицу, вычитая удаленное количество
    UPDATE public.daily_log
    SET 
        manufactured = manufactured - v_deleted_quantity,
        remaining = CASE WHEN v_remaining_was_not_null THEN NULL ELSE remaining END,
        updated_at = NOW()
    WHERE chat_id = p_chat_id AND log_date = v_log_date AND pie_type = v_pie_type;

    -- Возвращаем новый итог
    RETURN QUERY
    SELECT dl.manufactured, v_remaining_was_not_null AS remaining_reset
    FROM public.daily_log dl
    WHERE dl.chat_id = p_chat_id AND dl.log_date = v_log_date AND dl.pie_type = v_pie_type;
END;
$$;

-- ===================================================================
-- ШАГ 3: УДАЛЕНИЕ СТАРОЙ ФУНКЦИИ
-- ===================================================================
DROP FUNCTION IF EXISTS public.upsert_daily_manufactured(p_chat_id BIGINT, p_pie_type TEXT, p_add_quantity INT);